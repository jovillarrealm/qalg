<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>scrum_intro – qalg</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">qalg</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Algebra en Ciencia de Datos/1.html"> 
<span class="menu-text">Algebra</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../Gestion de proyectos/scrum_intro.html" aria-current="page"> 
<span class="menu-text">SCRUM</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Intro a aprendizaje de maquina/1.html"> 
<span class="menu-text">Introducción al aprendizaje de máquina</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#scrum" id="toc-scrum" class="nav-link active" data-scroll-target="#scrum">SCRUM</a>
  <ul class="collapse">
  <li><a href="#por-qué-scrum" id="toc-por-qué-scrum" class="nav-link" data-scroll-target="#por-qué-scrum">Por qué Scrum</a></li>
  <li><a href="#principios-scrum" id="toc-principios-scrum" class="nav-link" data-scroll-target="#principios-scrum">Principios Scrum</a></li>
  <li><a href="#aspectos-scrum" id="toc-aspectos-scrum" class="nav-link" data-scroll-target="#aspectos-scrum">Aspectos Scrum</a>
  <ul class="collapse">
  <li><a href="#roles-centrales" id="toc-roles-centrales" class="nav-link" data-scroll-target="#roles-centrales">Roles centrales</a></li>
  </ul></li>
  <li><a href="#procesos-scrum" id="toc-procesos-scrum" class="nav-link" data-scroll-target="#procesos-scrum">Procesos Scrum</a></li>
  <li><a href="#ceremonias-scrum" id="toc-ceremonias-scrum" class="nav-link" data-scroll-target="#ceremonias-scrum">Ceremonias Scrum</a></li>
  <li><a href="#consideraciones-misceláneas" id="toc-consideraciones-misceláneas" class="nav-link" data-scroll-target="#consideraciones-misceláneas">Consideraciones misceláneas</a>
  <ul class="collapse">
  <li><a href="#agile-ágil" id="toc-agile-ágil" class="nav-link" data-scroll-target="#agile-ágil">Agile (Ágil)</a></li>
  </ul></li>
  <li><a href="#principios-clave" id="toc-principios-clave" class="nav-link" data-scroll-target="#principios-clave">Principios clave:</a></li>
  </ul></li>
  <li><a href="#scrum-1" id="toc-scrum-1" class="nav-link" data-scroll-target="#scrum-1">Scrum</a>
  <ul class="collapse">
  <li><a href="#marco-de-trabajo-específico" id="toc-marco-de-trabajo-específico" class="nav-link" data-scroll-target="#marco-de-trabajo-específico">Marco de trabajo específico:</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="scrum" class="level1">
<h1>SCRUM</h1>
<p>Es un framework para hacer <a href="#agile-ágil">Agile (Ágil)</a></p>
<p>Scrum es una pose de Rugby. Se refiere a que tanto en el rugby como en Scrum, el trabajo en equipo es fundamental. En el rugby, los jugadores se unen en el scrum para empujar y luchar por el balón. En Scrum, los equipos se unen para colaborar y alcanzar los objetivos del proyecto.</p>
<p>Ambos enfatizan la importancia de la sincronización, la comunicación y el apoyo mutuo entre los miembros del equipo.</p>
<p>El rugby es un deporte dinámico donde las situaciones cambian constantemente. Los jugadores deben adaptarse y ajustar sus estrategias en tiempo real. De manera similar, Scrum promueve la adaptabilidad a los cambios en los requisitos del proyecto.</p>
<section id="por-qué-scrum" class="level2">
<h2 class="anchored" data-anchor-id="por-qué-scrum">Por qué Scrum</h2>
<ol type="1">
<li>Es centrado en el cliente.</li>
<li>Entrega continua permite manejar un paso sostenible, indefinidamente.</li>
<li>Permite manejar un ambiente donde los requisitos cambian constantemente.</li>
</ol>
<p>Scrum como metodología se compone de (Roles Scrum) y: - 6 Principios Scrum - 5 Aspectos Scrum - 19 Procesos Scrum con fases - Iniciar - Planificar y Estimar - Implementar - Revisar y retrospectiva - Lanzamiento</p>
</section>
<section id="principios-scrum" class="level2">
<h2 class="anchored" data-anchor-id="principios-scrum">Principios Scrum</h2>
<p>Son todos obligatorios</p>
<ol type="1">
<li>Control de procesos empíricos:</li>
</ol>
<ul>
<li>Scrum se basa en la experiencia y la observación, no en planes rígidos. Las decisiones se toman en función de lo que se aprende durante el desarrollo.</li>
<li>Se promueve la <em>transparencia</em>, la <em>inspección</em> y la <em>adaptación</em> continua.</li>
</ul>
<ol start="2" type="1">
<li>Autoorganización:</li>
</ol>
<ul>
<li>Los equipos Scrum se autogestionan y deciden cómo realizar el trabajo. Se fomenta la <em>autonomía</em> la <em>consciencia</em>, <em>articulación</em>, y <em>apropiación</em>. Se cree que los equipos son más productivos cuando tienen control sobre su propio trabajo.</li>
</ul>
<ol start="3" type="1">
<li>Colaboración:</li>
</ol>
<ul>
<li>Scrum enfatiza la comunicación y la cooperación entre todos los involucrados. Se busca un ambiente de trabajo en equipo donde todos aporten y se apoyen mutuamente. La colaboración entre los interesados, el equipo de desarrollo y el product owner es fundamental.</li>
</ul>
<ol start="4" type="1">
<li>Priorización basada en valor:</li>
</ol>
<ul>
<li>El Product Owner prioriza las funcionalidades del producto según su valor para el cliente. El equipo se enfoca en entregar primero las funcionalidades más importantes. Se busca maximizar el retorno de la inversión al entregar valor de forma temprana y continua.</li>
</ul>
<ol start="5" type="1">
<li>Time-boxing (Bloque de tiempo asignado):</li>
</ol>
<ul>
<li>Los eventos de Scrum tienen una duración fija (time-box). Esto ayuda a mantener el enfoque y la disciplina. Los Sprints son time boxed, al igual que los Daily scrum, el Sprint review y el Sprint retrospective.</li>
</ul>
<ol start="6" type="1">
<li>Desarrollo iterativo:</li>
</ol>
<ul>
<li>El trabajo se divide en ciclos cortos llamados Sprints. En cada Sprint, se entrega un incremento de producto funcional. Esto permite obtener retroalimentación temprana y realizar ajustes continuos.</li>
</ul>
</section>
<section id="aspectos-scrum" class="level2">
<h2 class="anchored" data-anchor-id="aspectos-scrum">Aspectos Scrum</h2>
<ul>
<li>Organización: Este aspecto se refiere a la estructura del equipo Scrum y cómo se organiza para trabajar de manera efectiva. Involucra la definición de roles (como el Product Owner, Scrum Master y el Equipo de Desarrollo) y la forma en que interactúan entre sí.</li>
<li>Justificación de Negocio: Se centra en el valor que el proyecto aporta al negocio. Implica comprender las necesidades del cliente, definir los objetivos del producto y asegurarse de que el trabajo del equipo esté alineado con las prioridades del negocio.</li>
<li>Calidad: La calidad es un aspecto fundamental en Scrum. Se refiere a la entrega de un producto que cumpla con los estándares de calidad definidos. Esto implica realizar pruebas, revisiones y mejoras continuas a lo largo del proceso de desarrollo.</li>
<li>Cambio: Scrum reconoce que los requisitos pueden cambiar durante el desarrollo. Este aspecto se refiere a la capacidad del equipo para adaptarse a los cambios y responder de manera flexible a las nuevas necesidades.</li>
<li>Riesgo: Todo proyecto conlleva riesgos. Scrum aborda el riesgo de manera proactiva, identificando y mitigando los posibles problemas que puedan surgir durante el desarrollo.</li>
</ul>
<section id="roles-centrales" class="level3">
<h3 class="anchored" data-anchor-id="roles-centrales">Roles centrales</h3>
<p>Propietario del Producto (Product Owner):</p>
<ul>
<li>Este rol representa los intereses de los stakeholders y es responsable de maximizar el valor del producto. El Product Owner define la visión del producto, prioriza el backlog del producto y asegura que el equipo de desarrollo comprenda los requisitos.</li>
</ul>
<p>Scrum Master:</p>
<ul>
<li>El Scrum Master es un facilitador que ayuda al equipo Scrum a seguir los principios y prácticas de Scrum. Elimina impedimentos, facilita las reuniones y se asegura de que el equipo esté trabajando de manera efectiva.</li>
</ul>
<p>Equipo de Desarrollo (Development Team):</p>
<ul>
<li>El equipo de desarrollo es responsable de entregar el incremento del producto en cada Sprint. Los miembros del equipo son autoorganizados y multifuncionales, lo que significa que tienen las habilidades necesarias para completar el trabajo.</li>
</ul>
</section>
</section>
<section id="procesos-scrum" class="level2">
<h2 class="anchored" data-anchor-id="procesos-scrum">Procesos Scrum</h2>
<p>A ver, un proyecto tiene un Product Backlog de requisitos priorizados.</p>
<p>Un product owner para hacer eso. Se hace con 19 actividades, metidas en 5 fases.</p>
<p>Hay algunos inputs, outputs y herramientas que pueden o no ser obligatorios.</p>
<ol type="1">
<li>Inicializar:
<ol type="1">
<li>Crear vision de producto. Se identifica Product Owner.</li>
<li>Identificar Scrum Master y Business Stakeholder (como cliente/usuario).</li>
<li>Formar Scrum Team.</li>
<li>Desarrollar Epicas.</li>
<li>Crear un Product Backlog (Priorizado). Las epicas se elaboran y priorizadas.</li>
<li>Release Planning. Compartible con stakeholders.</li>
<li>Estimar.</li>
<li>Crear Historias de usuario. (Usualmente por PO (Product Owner) y requiere al team).</li>
<li>Estimar historias de usuario.</li>
<li>Commit historias de usuario.</li>
<li>Identificar tareas.</li>
<li>Estimar Tareas(op).</li>
<li>Actualizar Backlog.</li>
</ol></li>
<li>Implementar:
<ol type="1">
<li>Crear Entregables.</li>
<li>Conducir la Daily Standup Meeting.</li>
<li>Refinar Backlog Priorizado.</li>
<li>Demostrar y validar Sprint.</li>
<li>Restrospectiva de Sprint.</li>
</ol></li>
<li>Release
<ol type="1">
<li>Shippear los entregables.</li>
<li>Retrospectiva de lanzamiento.</li>
</ol></li>
</ol>
</section>
<section id="ceremonias-scrum" class="level2">
<h2 class="anchored" data-anchor-id="ceremonias-scrum">Ceremonias Scrum</h2>
<ol type="1">
<li>Reunion de Visión de Proyecto</li>
<li>User group y Focus groups para levantar las historias de usuarios.</li>
<li>Sesiones de release planning.</li>
<li>Revisión de Backlog</li>
<li>Sprint planning</li>
<li>Dailys</li>
<li>Sprint Reviews</li>
<li>Retrospect Sprint Meeting</li>
<li>Retrospect Release Meeting</li>
</ol>
</section>
<section id="consideraciones-misceláneas" class="level2">
<h2 class="anchored" data-anchor-id="consideraciones-misceláneas">Consideraciones misceláneas</h2>
<p>Software sobre documentación. Escalar Scrum se hace con equipos pequeños que se sincronizan entre sí.</p>
<section id="agile-ágil" class="level3">
<h3 class="anchored" data-anchor-id="agile-ágil">Agile (Ágil)</h3>
<section id="enfoque-general" class="level4">
<h4 class="anchored" data-anchor-id="enfoque-general">Enfoque general:</h4>
<p>Agile es un enfoque o filosofía para la gestión de proyectos, especialmente en el desarrollo de software. Se centra en la flexibilidad, la adaptación y la entrega continua de valor. Se basa en la idea de que los requisitos de los proyectos pueden cambiar rápidamente, por lo que es importante poder adaptarse a esos cambios. Se busca la colaboración constante con el cliente y la retroalimentación continua.</p>
</section>
</section>
</section>
<section id="principios-clave" class="level2">
<h2 class="anchored" data-anchor-id="principios-clave">Principios clave:</h2>
<p>Priorizar la satisfacción del cliente. Aceptar los cambios en los requisitos. Entregar software funcional con frecuencia. Fomentar la colaboración entre los equipos. Promover la mejora continua.</p>
</section>
</section>
<section id="scrum-1" class="level1">
<h1>Scrum</h1>
<section id="marco-de-trabajo-específico" class="level2">
<h2 class="anchored" data-anchor-id="marco-de-trabajo-específico">Marco de trabajo específico:</h2>
<p>Scrum es un marco de trabajo ágil específico que ayuda a los equipos a implementar los principios de Agile. Proporciona una estructura para la gestión de proyectos, con roles, eventos y artefactos definidos. Se basa en la división del trabajo en ciclos cortos llamados “sprints”. Scrum es la metodología ágil más popular. Elementos clave: - Roles: Product Owner, Scrum Master, Equipo de Desarrollo. - Eventos: Sprint Planning, Daily Scrum, Sprint Review, Sprint Retrospective. Artefactos: Product Backlog, Sprint Backlog, Incremento.</p>
<p>Relación entre Agile y Scrum</p>
<p>Scrum es una de las muchas formas de implementar Agile. Agile es la filosofía, y Scrum es una forma práctica de ponerla en práctica. Scrum proporciona un marco de trabajo que ayuda a los equipos a ser ágiles. En resumen, podrías decir que todo equipo de Scrum es un equipo Ágil, pero no todos los equipos ágiles utilizan Scrum.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/jovillarrealm\.github\.io\/qalg\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>